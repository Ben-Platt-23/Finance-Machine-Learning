"""
Strategy Backtesting Framework

This module provides comprehensive backtesting capabilities to validate
the performance of the investment strategy using historical data.
It simulates trading based on the signals generated by the decision engine
and provides detailed performance analytics.

Key Features:
1. Historical simulation of trading signals
2. Performance metrics calculation (returns, Sharpe ratio, max drawdown)
3. Transaction cost modeling
4. Risk-adjusted performance analysis
5. Benchmark comparison
6. Detailed trade analysis
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
import logging
import sys
import os

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from data.data_fetcher import DataFetcher
from models.decision_engine import InvestmentDecisionEngine
from risk.portfolio_optimizer import PortfolioOptimizer

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class StrategyBacktester:
    """
    Comprehensive backtesting framework for investment strategies.
    
    This class simulates the investment strategy over historical periods
    and provides detailed performance analysis to validate the approach.
    """
    
    def __init__(self, 
                 initial_capital: float = 100000,
                 transaction_cost: float = 0.001,  # 0.1% per trade
                 benchmark: str = 'SPY'):
        """
        Initialize the backtester.
        
        Args:
            initial_capital: Starting portfolio value
            transaction_cost: Transaction cost as fraction of trade value
            benchmark: Benchmark symbol for comparison
        """
        self.initial_capital = initial_capital
        self.transaction_cost = transaction_cost
        self.benchmark = benchmark
        
        # Initialize components
        self.data_fetcher = DataFetcher()
        self.decision_engine = InvestmentDecisionEngine()
        self.portfolio_optimizer = PortfolioOptimizer()
        
        # Backtesting results storage
        self.trades = []
        self.portfolio_history = []
        self.performance_metrics = {}
        
    def run_backtest(self, 
                    symbols: List[str],
                    start_date: str,
                    end_date: str,
                    rebalance_frequency: str = 'weekly') -> Dict[str, Any]:
        """
        Run a complete backtest simulation.
        
        This function simulates the investment strategy over the specified
        time period and tracks all trades, portfolio values, and performance.
        
        Args:
            symbols: List of symbols to trade
            start_date: Start date for backtest (YYYY-MM-DD)
            end_date: End date for backtest (YYYY-MM-DD)
            rebalance_frequency: How often to rebalance ('daily', 'weekly', 'monthly')
            
        Returns:
            Dictionary with backtest results and performance metrics
        """
        logger.info(f"Starting backtest from {start_date} to {end_date}")
        logger.info(f"Symbols: {symbols}")
        logger.info(f"Rebalance frequency: {rebalance_frequency}")
        
        try:
            # 1. FETCH HISTORICAL DATA
            logger.info("Fetching historical data...")
            
            # Extend start date to have enough data for indicators
            extended_start = (pd.to_datetime(start_date) - timedelta(days=365)).strftime('%Y-%m-%d')
            
            price_data_dict = self.data_fetcher.get_stock_data(
                symbols + [self.benchmark], 
                period='max'  # Get maximum available data
            )
            
            # Filter data to the extended period
            for symbol in price_data_dict:
                df = price_data_dict[symbol]
                df = df[df.index >= extended_start]
                price_data_dict[symbol] = df
            
            # Get market data for context
            market_data = self.data_fetcher.get_market_data(period='max')
            market_data = market_data[market_data.index >= extended_start]
            
            # 2. PREPARE BACKTESTING PERIODS
            backtest_start = pd.to_datetime(start_date)
            backtest_end = pd.to_datetime(end_date)
            
            # Generate rebalancing dates
            if rebalance_frequency == 'daily':
                rebalance_dates = pd.bdate_range(backtest_start, backtest_end, freq='B')
            elif rebalance_frequency == 'weekly':
                rebalance_dates = pd.bdate_range(backtest_start, backtest_end, freq='W')
            elif rebalance_frequency == 'monthly':
                rebalance_dates = pd.bdate_range(backtest_start, backtest_end, freq='BM')
            else:
                raise ValueError(f"Unknown rebalance frequency: {rebalance_frequency}")
            
            # 3. INITIALIZE PORTFOLIO TRACKING
            current_positions = {symbol: 0.0 for symbol in symbols}  # Dollar amounts
            current_cash = self.initial_capital
            portfolio_value = self.initial_capital
            
            # 4. RUN SIMULATION
            logger.info(f"Running simulation with {len(rebalance_dates)} rebalancing periods...")
            
            for i, rebalance_date in enumerate(rebalance_dates):
                try:
                    # Get data up to current date for analysis
                    current_data_dict = {}
                    for symbol in symbols:
                        if symbol in price_data_dict:
                            symbol_data = price_data_dict[symbol]
                            current_data = symbol_data[symbol_data.index <= rebalance_date]
                            
                            if len(current_data) >= 100:  # Need minimum history
                                current_data_dict[symbol] = current_data
                    
                    if not current_data_dict:
                        continue
                    
                    # Get current market data
                    current_market_data = market_data[market_data.index <= rebalance_date]
                    
                    # 5. GENERATE SIGNALS
                    # Train models with data up to current date (avoiding look-ahead bias)
                    self._train_models_for_backtest(current_data_dict, rebalance_date)
                    
                    # Generate investment signals
                    portfolio_analysis = self.decision_engine.analyze_portfolio(
                        symbols=list(current_data_dict.keys()),
                        price_data_dict=current_data_dict,
                        market_data=current_market_data,
                        current_positions=current_positions
                    )
                    
                    # 6. CALCULATE NEW POSITION SIZES
                    individual_signals = portfolio_analysis.get('individual_signals', {})
                    
                    # Convert signals to position sizing format
                    signals_for_sizing = {}
                    for symbol, signal in individual_signals.items():
                        if signal.signal_type == 'BUY':
                            signals_for_sizing[symbol] = signal.confidence * 0.5  # Scale down for safety
                        elif signal.signal_type == 'SELL':
                            signals_for_sizing[symbol] = -signal.confidence * 0.5
                        else:
                            signals_for_sizing[symbol] = 0
                    
                    # Calculate target positions
                    if signals_for_sizing:
                        # Update portfolio value based on current prices
                        portfolio_value = self._calculate_portfolio_value(
                            current_positions, current_data_dict, rebalance_date, current_cash
                        )
                        
                        # Calculate position sizes
                        returns_data = pd.DataFrame()
                        for symbol in signals_for_sizing.keys():
                            if symbol in current_data_dict:
                                returns_data[symbol] = current_data_dict[symbol]['close'].pct_change()
                        
                        if not returns_data.empty:
                            target_positions = self.portfolio_optimizer.calculate_position_sizes(
                                signals=signals_for_sizing,
                                portfolio_value=portfolio_value,
                                returns=returns_data,
                                max_position_size=0.1  # Conservative position sizing for backtest
                            )
                        else:
                            target_positions = {}
                    else:
                        target_positions = {}
                    
                    # 7. EXECUTE TRADES
                    trades_executed = self._execute_trades(
                        current_positions=current_positions,
                        target_positions=target_positions,
                        price_data_dict=current_data_dict,
                        trade_date=rebalance_date,
                        current_cash=current_cash
                    )
                    
                    # Update cash and positions
                    for trade in trades_executed:
                        current_cash -= trade['net_amount']  # Includes transaction costs
                        current_positions[trade['symbol']] += trade['quantity'] * trade['price']
                    
                    # 8. RECORD PORTFOLIO STATE
                    portfolio_value = self._calculate_portfolio_value(
                        current_positions, current_data_dict, rebalance_date, current_cash
                    )
                    
                    portfolio_record = {
                        'date': rebalance_date,
                        'portfolio_value': portfolio_value,
                        'cash': current_cash,
                        'positions': current_positions.copy(),
                        'signals_generated': len(individual_signals),
                        'trades_executed': len(trades_executed)
                    }
                    
                    self.portfolio_history.append(portfolio_record)
                    
                    # Progress logging
                    if i % 10 == 0 or i == len(rebalance_dates) - 1:
                        progress = (i + 1) / len(rebalance_dates) * 100
                        logger.info(f"Progress: {progress:.1f}% - Portfolio Value: ${portfolio_value:,.0f}")
                
                except Exception as e:
                    logger.error(f"Error processing {rebalance_date}: {e}")
                    continue
            
            # 9. CALCULATE PERFORMANCE METRICS
            logger.info("Calculating performance metrics...")
            performance_metrics = self._calculate_performance_metrics(
                price_data_dict.get(self.benchmark), backtest_start, backtest_end
            )
            
            # 10. COMPILE RESULTS
            backtest_results = {
                'backtest_config': {
                    'start_date': start_date,
                    'end_date': end_date,
                    'symbols': symbols,
                    'initial_capital': self.initial_capital,
                    'transaction_cost': self.transaction_cost,
                    'benchmark': self.benchmark,
                    'rebalance_frequency': rebalance_frequency
                },
                'performance_metrics': performance_metrics,
                'portfolio_history': self.portfolio_history,
                'trades': self.trades,
                'final_portfolio_value': portfolio_value,
                'total_return': (portfolio_value / self.initial_capital - 1) * 100
            }
            
            logger.info(f"Backtest completed successfully!")
            logger.info(f"Final Portfolio Value: ${portfolio_value:,.0f}")
            logger.info(f"Total Return: {backtest_results['total_return']:.2f}%")
            
            return backtest_results
            
        except Exception as e:
            logger.error(f"Error in backtest execution: {e}")
            return {'error': str(e)}
    
    def _train_models_for_backtest(self, price_data_dict: Dict[str, pd.DataFrame], current_date: pd.Timestamp):
        """
        Train models using only data available up to the current date.
        
        This prevents look-ahead bias by ensuring models only use historical data.
        """
        try:
            # Only retrain models periodically to save computation
            if not hasattr(self, '_last_model_training') or \
               (current_date - self._last_model_training).days >= 30:  # Retrain monthly
                
                # Prepare training data
                combined_features = pd.DataFrame()
                
                for symbol, price_data in price_data_dict.items():
                    # Use data up to current date
                    historical_data = price_data[price_data.index < current_date]
                    
                    if len(historical_data) >= 100:  # Need minimum history
                        # Calculate indicators and features
                        enriched_data = self.decision_engine.technical_analyzer.calculate_all_indicators(historical_data)
                        ml_features = self.decision_engine.ml_models.prepare_features(enriched_data)
                        
                        # Add to combined dataset
                        ml_features['symbol'] = symbol
                        combined_features = pd.concat([combined_features, ml_features], ignore_index=True)
                
                if not combined_features.empty:
                    training_data = combined_features.drop('symbol', axis=1)
                    
                    # Train models
                    try:
                        self.decision_engine.ml_models.train_direction_classifier(training_data)
                        self.decision_engine.ml_models.train_movement_regressor(training_data)
                        self._last_model_training = current_date
                        
                    except Exception as e:
                        logger.warning(f"Model training failed for {current_date}: {e}")
                        
        except Exception as e:
            logger.warning(f"Error in model training: {e}")
    
    def _calculate_portfolio_value(self, 
                                 positions: Dict[str, float], 
                                 price_data_dict: Dict[str, pd.DataFrame], 
                                 date: pd.Timestamp,
                                 cash: float) -> float:
        """
        Calculate current portfolio value based on positions and market prices.
        """
        portfolio_value = cash
        
        for symbol, position_value in positions.items():
            if symbol in price_data_dict and position_value != 0:
                symbol_data = price_data_dict[symbol]
                
                # Get price on or before the date
                available_data = symbol_data[symbol_data.index <= date]
                
                if not available_data.empty:
                    current_price = available_data['close'].iloc[-1]
                    # Position value is in dollars, so we don't need to multiply by price again
                    # Just add the current market value
                    shares = position_value / current_price if current_price > 0 else 0
                    current_value = shares * current_price
                    portfolio_value += current_value
        
        return portfolio_value
    
    def _execute_trades(self, 
                       current_positions: Dict[str, float],
                       target_positions: Dict[str, float],
                       price_data_dict: Dict[str, pd.DataFrame],
                       trade_date: pd.Timestamp,
                       current_cash: float) -> List[Dict]:
        """
        Execute trades to move from current positions to target positions.
        """
        trades_executed = []
        
        # Get all symbols
        all_symbols = set(current_positions.keys()) | set(target_positions.keys())
        
        for symbol in all_symbols:
            current_pos = current_positions.get(symbol, 0)
            target_pos = target_positions.get(symbol, 0)
            
            # Calculate trade size
            trade_amount = target_pos - current_pos
            
            if abs(trade_amount) > 100:  # Only trade if difference > $100
                if symbol in price_data_dict:
                    symbol_data = price_data_dict[symbol]
                    available_data = symbol_data[symbol_data.index <= trade_date]
                    
                    if not available_data.empty:
                        trade_price = available_data['close'].iloc[-1]
                        
                        # Calculate shares to trade
                        shares_to_trade = trade_amount / trade_price if trade_price > 0 else 0
                        
                        # Calculate transaction cost
                        transaction_cost = abs(trade_amount) * self.transaction_cost
                        
                        # Net amount including costs
                        net_amount = trade_amount + (transaction_cost if trade_amount > 0 else -transaction_cost)
                        
                        # Check if we have enough cash for buy orders
                        if trade_amount > 0 and net_amount > current_cash:
                            # Reduce trade size to available cash
                            available_for_trade = current_cash * 0.95  # Leave 5% buffer
                            trade_amount = available_for_trade - transaction_cost
                            shares_to_trade = trade_amount / trade_price
                            net_amount = trade_amount + transaction_cost
                        
                        if abs(shares_to_trade) > 0.01:  # Minimum trade size
                            trade_record = {
                                'date': trade_date,
                                'symbol': symbol,
                                'action': 'BUY' if trade_amount > 0 else 'SELL',
                                'quantity': abs(shares_to_trade),
                                'price': trade_price,
                                'gross_amount': abs(trade_amount),
                                'transaction_cost': transaction_cost,
                                'net_amount': net_amount
                            }
                            
                            trades_executed.append(trade_record)
                            self.trades.append(trade_record)
        
        return trades_executed
    
    def _calculate_performance_metrics(self, 
                                     benchmark_data: pd.DataFrame,
                                     start_date: pd.Timestamp,
                                     end_date: pd.Timestamp) -> Dict[str, float]:
        """
        Calculate comprehensive performance metrics.
        """
        if not self.portfolio_history:
            return {}
        
        # Convert portfolio history to DataFrame
        portfolio_df = pd.DataFrame(self.portfolio_history)
        portfolio_df.set_index('date', inplace=True)
        
        # Filter to backtest period
        portfolio_df = portfolio_df[
            (portfolio_df.index >= start_date) & 
            (portfolio_df.index <= end_date)
        ]
        
        if portfolio_df.empty:
            return {}
        
        # Calculate returns
        portfolio_values = portfolio_df['portfolio_value']
        portfolio_returns = portfolio_values.pct_change().dropna()
        
        # Calculate benchmark returns
        benchmark_returns = pd.Series()
        if benchmark_data is not None and not benchmark_data.empty:
            benchmark_data = benchmark_data[
                (benchmark_data.index >= start_date) & 
                (benchmark_data.index <= end_date)
            ]
            benchmark_returns = benchmark_data['close'].pct_change().dropna()
        
        # Basic performance metrics
        total_return = (portfolio_values.iloc[-1] / portfolio_values.iloc[0] - 1) * 100
        annualized_return = ((portfolio_values.iloc[-1] / portfolio_values.iloc[0]) ** 
                           (252 / len(portfolio_returns))) - 1 if len(portfolio_returns) > 0 else 0
        
        # Risk metrics
        volatility = portfolio_returns.std() * np.sqrt(252) * 100  # Annualized volatility
        
        # Sharpe ratio
        risk_free_rate = 0.02  # 2% risk-free rate
        excess_returns = portfolio_returns.mean() * 252 - risk_free_rate
        sharpe_ratio = excess_returns / (volatility / 100) if volatility > 0 else 0
        
        # Maximum drawdown
        cumulative_returns = (1 + portfolio_returns).cumprod()
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min() * 100
        
        # Win rate
        positive_returns = portfolio_returns > 0
        win_rate = positive_returns.mean() * 100
        
        # Benchmark comparison
        benchmark_metrics = {}
        if not benchmark_returns.empty:
            # Align dates
            common_dates = portfolio_returns.index.intersection(benchmark_returns.index)
            if len(common_dates) > 0:
                aligned_portfolio = portfolio_returns.loc[common_dates]
                aligned_benchmark = benchmark_returns.loc[common_dates]
                
                benchmark_total_return = ((1 + aligned_benchmark).prod() - 1) * 100
                benchmark_volatility = aligned_benchmark.std() * np.sqrt(252) * 100
                
                # Alpha and Beta
                covariance = np.cov(aligned_portfolio, aligned_benchmark)[0, 1]
                benchmark_variance = np.var(aligned_benchmark)
                beta = covariance / benchmark_variance if benchmark_variance > 0 else 0
                
                alpha = (aligned_portfolio.mean() - beta * aligned_benchmark.mean()) * 252 * 100
                
                benchmark_metrics = {
                    'benchmark_total_return': benchmark_total_return,
                    'benchmark_volatility': benchmark_volatility,
                    'alpha': alpha,
                    'beta': beta,
                    'excess_return': total_return - benchmark_total_return
                }
        
        # Trade analysis
        trade_analysis = {}
        if self.trades:
            total_trades = len(self.trades)
            total_transaction_costs = sum(trade['transaction_cost'] for trade in self.trades)
            avg_trade_size = np.mean([trade['gross_amount'] for trade in self.trades])
            
            trade_analysis = {
                'total_trades': total_trades,
                'total_transaction_costs': total_transaction_costs,
                'avg_trade_size': avg_trade_size,
                'transaction_cost_pct': (total_transaction_costs / self.initial_capital) * 100
            }
        
        # Combine all metrics
        performance_metrics = {
            'total_return_pct': total_return,
            'annualized_return_pct': annualized_return * 100,
            'volatility_pct': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown_pct': max_drawdown,
            'win_rate_pct': win_rate,
            **benchmark_metrics,
            **trade_analysis
        }
        
        return performance_metrics
    
    def generate_report(self, backtest_results: Dict[str, Any], save_path: str = None):
        """
        Generate a comprehensive backtest report with visualizations.
        """
        if 'error' in backtest_results:
            print(f"Cannot generate report due to error: {backtest_results['error']}")
            return
        
        # Print text report
        self._print_backtest_report(backtest_results)
        
        # Generate visualizations
        if save_path:
            self._create_backtest_charts(backtest_results, save_path)
    
    def _print_backtest_report(self, results: Dict[str, Any]):
        """Print formatted backtest report to console."""
        config = results['backtest_config']
        metrics = results['performance_metrics']
        
        print("\n" + "="*80)
        print("STRATEGY BACKTEST REPORT")
        print("="*80)
        
        # Configuration
        print(f"Period: {config['start_date']} to {config['end_date']}")
        print(f"Initial Capital: ${config['initial_capital']:,.0f}")
        print(f"Final Portfolio Value: ${results['final_portfolio_value']:,.0f}")
        print(f"Symbols Traded: {', '.join(config['symbols'])}")
        print(f"Rebalance Frequency: {config['rebalance_frequency']}")
        
        # Performance metrics
        print(f"\n📈 PERFORMANCE METRICS:")
        print("-" * 50)
        print(f"Total Return: {metrics.get('total_return_pct', 0):.2f}%")
        print(f"Annualized Return: {metrics.get('annualized_return_pct', 0):.2f}%")
        print(f"Volatility: {metrics.get('volatility_pct', 0):.2f}%")
        print(f"Sharpe Ratio: {metrics.get('sharpe_ratio', 0):.3f}")
        print(f"Maximum Drawdown: {metrics.get('max_drawdown_pct', 0):.2f}%")
        print(f"Win Rate: {metrics.get('win_rate_pct', 0):.1f}%")
        
        # Benchmark comparison
        if 'benchmark_total_return' in metrics:
            print(f"\n📊 BENCHMARK COMPARISON ({config['benchmark']}):")
            print("-" * 50)
            print(f"Strategy Return: {metrics['total_return_pct']:.2f}%")
            print(f"Benchmark Return: {metrics['benchmark_total_return']:.2f}%")
            print(f"Excess Return: {metrics.get('excess_return', 0):.2f}%")
            print(f"Alpha: {metrics.get('alpha', 0):.2f}%")
            print(f"Beta: {metrics.get('beta', 0):.3f}")
        
        # Trade analysis
        if 'total_trades' in metrics:
            print(f"\n💼 TRADE ANALYSIS:")
            print("-" * 50)
            print(f"Total Trades: {metrics['total_trades']}")
            print(f"Average Trade Size: ${metrics.get('avg_trade_size', 0):,.0f}")
            print(f"Total Transaction Costs: ${metrics.get('total_transaction_costs', 0):,.0f}")
            print(f"Transaction Cost %: {metrics.get('transaction_cost_pct', 0):.3f}%")
        
        print("\n" + "="*80)
    
    def _create_backtest_charts(self, results: Dict[str, Any], save_path: str):
        """Create and save backtest visualization charts."""
        try:
            import matplotlib.pyplot as plt
            import matplotlib.dates as mdates
            
            portfolio_history = pd.DataFrame(results['portfolio_history'])
            portfolio_history.set_index('date', inplace=True)
            
            # Create subplots
            fig, axes = plt.subplots(2, 2, figsize=(15, 10))
            fig.suptitle('Strategy Backtest Results', fontsize=16)
            
            # Portfolio value over time
            axes[0, 0].plot(portfolio_history.index, portfolio_history['portfolio_value'])
            axes[0, 0].set_title('Portfolio Value Over Time')
            axes[0, 0].set_ylabel('Portfolio Value ($)')
            axes[0, 0].grid(True)
            
            # Returns distribution
            returns = portfolio_history['portfolio_value'].pct_change().dropna()
            axes[0, 1].hist(returns * 100, bins=50, alpha=0.7)
            axes[0, 1].set_title('Daily Returns Distribution')
            axes[0, 1].set_xlabel('Daily Return (%)')
            axes[0, 1].set_ylabel('Frequency')
            axes[0, 1].grid(True)
            
            # Drawdown chart
            cumulative = (1 + returns).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max * 100
            
            axes[1, 0].fill_between(drawdown.index, drawdown, 0, alpha=0.3, color='red')
            axes[1, 0].plot(drawdown.index, drawdown, color='red')
            axes[1, 0].set_title('Drawdown Over Time')
            axes[1, 0].set_ylabel('Drawdown (%)')
            axes[1, 0].grid(True)
            
            # Monthly returns heatmap
            monthly_returns = returns.resample('M').apply(lambda x: (1 + x).prod() - 1) * 100
            monthly_returns.index = monthly_returns.index.strftime('%Y-%m')
            
            # Reshape for heatmap (simplified version)
            years = sorted(set([date[:4] for date in monthly_returns.index]))
            months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']
            
            heatmap_data = []
            for year in years:
                year_data = []
                for month in months:
                    key = f"{year}-{month}"
                    if key in monthly_returns.index:
                        year_data.append(monthly_returns[key])
                    else:
                        year_data.append(np.nan)
                heatmap_data.append(year_data)
            
            if heatmap_data:
                im = axes[1, 1].imshow(heatmap_data, cmap='RdYlGn', aspect='auto')
                axes[1, 1].set_title('Monthly Returns Heatmap (%)')
                axes[1, 1].set_xticks(range(12))
                axes[1, 1].set_xticklabels(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
                axes[1, 1].set_yticks(range(len(years)))
                axes[1, 1].set_yticklabels(years)
                
                # Add colorbar
                plt.colorbar(im, ax=axes[1, 1])
            
            plt.tight_layout()
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            logger.info(f"Backtest charts saved to {save_path}")
            
        except Exception as e:
            logger.error(f"Error creating charts: {e}")


def main():
    """Example usage of the backtesting framework."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Strategy Backtester')
    parser.add_argument('--start-date', type=str, default='2022-01-01',
                       help='Backtest start date (YYYY-MM-DD)')
    parser.add_argument('--end-date', type=str, default='2023-12-31',
                       help='Backtest end date (YYYY-MM-DD)')
    parser.add_argument('--symbols', type=str, default='AAPL,GOOGL,MSFT,AMZN,TSLA',
                       help='Comma-separated list of symbols')
    parser.add_argument('--capital', type=float, default=100000,
                       help='Initial capital')
    parser.add_argument('--frequency', type=str, default='weekly',
                       choices=['daily', 'weekly', 'monthly'],
                       help='Rebalancing frequency')
    
    args = parser.parse_args()
    
    # Parse symbols
    symbols = [s.strip().upper() for s in args.symbols.split(',')]
    
    # Initialize backtester
    backtester = StrategyBacktester(initial_capital=args.capital)
    
    # Run backtest
    results = backtester.run_backtest(
        symbols=symbols,
        start_date=args.start_date,
        end_date=args.end_date,
        rebalance_frequency=args.frequency
    )
    
    # Generate report
    backtester.generate_report(results, save_path='backtest_results.png')
    
    print("\nBacktest completed! Check 'backtest_results.png' for visualizations.")


if __name__ == "__main__":
    main()
